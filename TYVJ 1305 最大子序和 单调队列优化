给定一个数列，求长度不超过M的子序列和的最大值
简单的做法就是N平方，求出sum以后看 sum[i]-sum[j] (i-j<=m)
但是题目的N范围给到了30万，只能用更快的解法

其实题目考查的就是单调队列的优化。数组和双端队列的写法

        public void solve(InputReader in, PrintWriter out) throws IOException {        	
        	n = in.nextInt();
        	m = in.nextInt();
        	arr = new int[n];
        	sum = new int[n];
        	for(int i=0;i<n;i++){
        		arr[i] = in.nextInt();
        		sum[i] = arr[i];
        		if(i>0) sum[i]+=sum[i-1];
        	}
//        	int h=0, t=0;
//        	int q[] = new int[n];
//        	int max = sum[0];
//        	for(int i=1;i<n;i++){
//        		while(h<=t&&i-q[h]>m) h++;
//        		if(sum[i]-sum[q[h]]>max) max = sum[i]-sum[q[h]];
//        		while(h<=t&&sum[q[t]]>sum[i]) t--;
//        		t++; q[t] = i;
//        	}
        	int max = sum[0];
        	Deque<Integer> q = new ArrayDeque<Integer>();
        	q.add(0);
        	for(int i=1;i<n;i++){
        		while(!q.isEmpty()&&i-q.peekFirst()>m) q.removeFirst();        			
        		if(sum[i]-sum[q.peek()]>max) max = sum[i]-sum[q.peek()];
        		while(!q.isEmpty()&&sum[q.peekLast()]>sum[i]) q.removeLast();
        		q.add(i);
        	}
        	System.out.println(max);
        	out.close();
        }
