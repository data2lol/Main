题意： 一堆物品，每个有花费，价值；物品的重要度是 花费*价值
给你一定的钱，求能买的最大重要度。这样的话是一个简单01背包
题目变化的地方在于“附件”这个概念，一个物体买的时候必须先买另外一个，就像选课时候有些课必须修完前续。

由于规定了一个物品最多两个附件，所以只有5种情况
dp[i] = max(dp[i],                            //一个都不选
            dp[i-w0]+w0*v0                    //只选主件
            dp[i-w0-w1]+w0*v0+w1*v1           //只选主件和附件1
            dp[i-w0-w2]+w0*v0+w2*v2           //只选主件和附件1
            dp[i-w0-w1-w2]+w0*v0+w1*v1+w2*v2) //全选
            
因为其他题目可能附件数不是一定的，这样的话需要更一般的算法。
背包九讲里的解法是把这个子集做一个背包，就是两次背包。这个题目没那么复杂。枚举组合就可以

    static class item{
    	int val,cost,imp;
    	public item(int a, int b, int c){
    		cost=a;val=b;imp=c;
    	}
    }
    static class group{
    	ArrayList<item> g;
    	item main;
    	item sub_1;
    	item sub_2;
    	public group(){
    		g = new ArrayList<item>();
    		main = sub_1 = sub_2 = null;
    	}
    	public boolean is_empty(){
    		return main==null;
    	}
    	public void get_combines(){
    		if(this.is_empty()) return;
    		g.add(main);
    		if(sub_1!=null){
    			g.add(new item(main.cost+sub_1.cost,
    							main.val+sub_1.val,
    							main.imp+sub_1.imp
    							));
    		}
    		if(sub_2!=null){
    			g.add(new item(main.cost+sub_2.cost,
    							main.val+sub_2.val,
    							main.imp+sub_2.imp
    							));
    		}  
    		if(sub_1!=null&&sub_2!=null){
    			g.add(new item(main.cost+sub_2.cost+sub_1.cost,
    							main.val+sub_2.val+sub_1.val,
    							main.imp+sub_2.imp+sub_1.imp
    							));
    		}     		
    	}
    }
    
    static class Task implements Runnable{
    	int n,m;
    	group groups[];
        public void solve(InputReader in, PrintWriter out) throws IOException {
        	n = in.nextInt();
        	n/=10;
        	m = in.nextInt();
        	groups = new group[m+1];
        	for(int i=1;i<=m;i++) groups[i] = new group();
        	for(int i=1;i<=m;i++){
        		int cost = in.nextInt()/10;
        		int val = in.nextInt();
        		int is_sub = in.nextInt();
        		if(is_sub==0){
        			groups[i].main = new item(cost,val,cost*val);
        		}else{
        			if(groups[is_sub].sub_1==null){
        				groups[is_sub].sub_1 = new item(cost,val,cost*val);
        			}
        			else if(groups[is_sub].sub_2==null){
        				groups[is_sub].sub_2 = new item(cost,val,cost*val);
        			}
        			else{
        				System.out.println("error");
        			}
        		}
        	}
        	for(int i=1;i<=m;i++){
        		groups[i].get_combines();
        	}
        	dp();
        }
        public void dp(){
        	int dp[] = new int[n+1];
        	for(int i=1;i<=m;i++){
        		if(groups[i].is_empty()) continue;
        		for(int j=n;j>=0;j--){ //把val循环放着一层巧妙保证每个子集只选一个解
        			for(int k=0;k<groups[i].g.size();k++){
        				item t = groups[i].g.get(k);
        				if(j<t.cost) continue;
        				dp[j] = Math.max(dp[j], dp[j-t.cost]+t.imp);
        			}
        		}
        	}
        	System.out.println(dp[n]*10);
        }
